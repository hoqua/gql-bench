/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../apps/api/src/app/app.module.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const tslib_1 = __webpack_require__("tslib");
const common_1 = __webpack_require__("@nestjs/common");
const path = __webpack_require__("node:path");
const message_module_1 = __webpack_require__("../apps/api/src/app/resources/message/message.module.ts");
const graphql_1 = __webpack_require__("@nestjs/graphql");
const mercurius_1 = __webpack_require__("@nestjs/mercurius");
const EventEmitter = __webpack_require__("events");
const ioredis_1 = __webpack_require__("ioredis");
const redis = new ioredis_1.default(12000);
const sub = new ioredis_1.default(12000);
const pub = new ioredis_1.default(12000);
class CustomPubSub {
    constructor() {
        this.emitter = new EventEmitter();
    }
    subscribe(topic, queue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            console.log('subscribed to', topic);
            let subscribed = true;
            const startReadingStream = (topic) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                while (subscribed) {
                    console.log('READING STREAM', topic);
                    const text = yield readMessages(topic);
                    console.log('RESULT', text);
                    this.publish({ topic, payload: { ['commentAdded']: { text } } }, () => { });
                }
            });
            const listener = (value) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                queue.push(value);
            });
            const close = () => {
                subscribed = false;
                this.emitter.removeListener(topic, listener);
            };
            // check subscription on same topic
            this.emitter.on(topic, listener);
            queue.close = close;
            startReadingStream(topic).catch((_) => (subscribed = false));
        });
    }
    publish(event, callback) {
        this.emitter.emit(event.topic, event.payload);
        callback();
    }
}
function readMessages(topic) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // `results` is an array, each element of which corresponds to a key.
        // Because we only listen to one key (mystream) here, `results` only contains
        // a single element. See more: https://redis.io/commands/xread#return-value
        const results = yield sub.xread('BLOCK', 0, 'STREAMS', topic, '$');
        const [key, messages] = results[0]; // `key` equals to "user-stream"
        console.log(messages);
        return messages.toString();
    });
}
// const items = await redis.xrange('user-stream', '-', '+', 'COUNT', 40);
// console.log(items);
// setInterval(() => {
//   // `redis` is in the block mode due to `redis.xread('BLOCK', ....)`,
//   // so we use another connection to publish messages.
//   const pushToTopic = Math.floor(Math.random() * 3).toString();
//   console.log('pushing to', pushToTopic);
//   pub.xadd(
//     pushToTopic,
//     'MAXLEN',
//     '~',
//     '20',
//     '*',
//     'message id' + pushToTopic,
//     'message text pushed to topic'
//   );
// }, 1000);
let AppModule = class AppModule {
};
AppModule = tslib_1.__decorate([
    (0, common_1.Module)({
        imports: [
            graphql_1.GraphQLModule.forRoot({
                driver: mercurius_1.MercuriusDriver,
                autoSchemaFile: path.join(__dirname, './autogenerated-schema.gql'),
                graphiql: 'graphiql',
                routes: true,
                subscription: {
                    pubsub: new CustomPubSub(),
                },
            }),
            message_module_1.MessageModule,
        ],
        controllers: [],
        providers: [],
    })
], AppModule);
exports.AppModule = AppModule;


/***/ }),

/***/ "../apps/api/src/app/resources/message/entities/message.entity.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
const tslib_1 = __webpack_require__("tslib");
const graphql_1 = __webpack_require__("@nestjs/graphql");
let Message = class Message {
};
tslib_1.__decorate([
    (0, graphql_1.Field)(() => String, { nullable: true }),
    tslib_1.__metadata("design:type", String)
], Message.prototype, "text", void 0);
Message = tslib_1.__decorate([
    (0, graphql_1.ObjectType)()
], Message);
exports.Message = Message;


/***/ }),

/***/ "../apps/api/src/app/resources/message/message.module.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageModule = void 0;
const tslib_1 = __webpack_require__("tslib");
const common_1 = __webpack_require__("@nestjs/common");
const message_service_1 = __webpack_require__("../apps/api/src/app/resources/message/message.service.ts");
const message_resolver_1 = __webpack_require__("../apps/api/src/app/resources/message/message.resolver.ts");
let MessageModule = class MessageModule {
};
MessageModule = tslib_1.__decorate([
    (0, common_1.Module)({
        providers: [message_resolver_1.MessageResolver, message_service_1.MessageService],
    })
], MessageModule);
exports.MessageModule = MessageModule;


/***/ }),

/***/ "../apps/api/src/app/resources/message/message.resolver.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageResolver = void 0;
const tslib_1 = __webpack_require__("tslib");
const graphql_1 = __webpack_require__("@nestjs/graphql");
const message_service_1 = __webpack_require__("../apps/api/src/app/resources/message/message.service.ts");
const message_entity_1 = __webpack_require__("../apps/api/src/app/resources/message/entities/message.entity.ts");
const mercurius_1 = __webpack_require__("mercurius");
let MessageResolver = class MessageResolver {
    constructor(messageService) {
        this.messageService = messageService;
    }
    commentAdded(pubSub, id) {
        console.log('RESOLVER EXECUTED', id);
        return pubSub.subscribe(id.toString());
    }
    addMessage(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.messageService.addMessage(id);
            return true;
        });
    }
    readMessage(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.messageService.readMessage(id);
        });
    }
};
tslib_1.__decorate([
    (0, graphql_1.Subscription)((returns) => message_entity_1.Message),
    tslib_1.__param(0, (0, graphql_1.Context)('pubsub')),
    tslib_1.__param(1, (0, graphql_1.Args)('id', { type: () => graphql_1.Int })),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [typeof (_a = typeof mercurius_1.PubSub !== "undefined" && mercurius_1.PubSub) === "function" ? _a : Object, Number]),
    tslib_1.__metadata("design:returntype", void 0)
], MessageResolver.prototype, "commentAdded", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => Boolean),
    tslib_1.__param(0, (0, graphql_1.Args)('id')),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [typeof (_b = typeof String !== "undefined" && String) === "function" ? _b : Object]),
    tslib_1.__metadata("design:returntype", Promise)
], MessageResolver.prototype, "addMessage", null);
tslib_1.__decorate([
    (0, graphql_1.Query)((returns) => message_entity_1.Message, { nullable: true }),
    tslib_1.__param(0, (0, graphql_1.Args)('id')),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [typeof (_c = typeof String !== "undefined" && String) === "function" ? _c : Object]),
    tslib_1.__metadata("design:returntype", Promise)
], MessageResolver.prototype, "readMessage", null);
MessageResolver = tslib_1.__decorate([
    (0, graphql_1.Resolver)(() => message_entity_1.Message),
    tslib_1.__metadata("design:paramtypes", [typeof (_d = typeof message_service_1.MessageService !== "undefined" && message_service_1.MessageService) === "function" ? _d : Object])
], MessageResolver);
exports.MessageResolver = MessageResolver;


/***/ }),

/***/ "../apps/api/src/app/resources/message/message.service.ts":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageService = void 0;
const tslib_1 = __webpack_require__("tslib");
const common_1 = __webpack_require__("@nestjs/common");
const ioredis_1 = __webpack_require__("ioredis");
const pub = new ioredis_1.default(12000);
function readMessages(topic) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // `results` is an array, each element of which corresponds to a key.
        // Because we only listen to one key (mystream) here, `results` only contains
        // a single element. See more: https://redis.io/commands/xread#return-value
        console.log('READ BLOCK', 0, 'STREAMS', topic, '$');
        const sub = new ioredis_1.default(12000);
        const results = yield sub.xread('BLOCK', 0, 'STREAMS', topic, '$');
        console.log(results);
        const [key, messages] = (results === null || results === void 0 ? void 0 : results[0]) || []; // `key` equals to "user-stream"
        return messages === null || messages === void 0 ? void 0 : messages.toString();
    });
}
const getRandomNumberAsString = () => Math.floor(Math.random() * 1000).toString();
let MessageService = class MessageService {
    addMessage(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            console.log('pushing to', id);
            const pushToTopic = id || getRandomNumberAsString();
            yield pub.xadd(pushToTopic, 'MAXLEN', '~', '20', '*', 'message id' + pushToTopic, 'message text pushed to topic | message text pushed to topic | message text pushed to topic | message text pushed to topic');
            return undefined;
        });
    }
    readMessage(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const text = yield readMessages(id || getRandomNumberAsString());
            return { text };
        });
    }
};
MessageService = tslib_1.__decorate([
    (0, common_1.Injectable)()
], MessageService);
exports.MessageService = MessageService;


/***/ }),

/***/ "@nestjs/common":
/***/ ((module) => {

module.exports = require("@nestjs/common");

/***/ }),

/***/ "@nestjs/core":
/***/ ((module) => {

module.exports = require("@nestjs/core");

/***/ }),

/***/ "@nestjs/graphql":
/***/ ((module) => {

module.exports = require("@nestjs/graphql");

/***/ }),

/***/ "@nestjs/mercurius":
/***/ ((module) => {

module.exports = require("@nestjs/mercurius");

/***/ }),

/***/ "@nestjs/platform-fastify":
/***/ ((module) => {

module.exports = require("@nestjs/platform-fastify");

/***/ }),

/***/ "events":
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "ioredis":
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "mercurius":
/***/ ((module) => {

module.exports = require("mercurius");

/***/ }),

/***/ "tslib":
/***/ ((module) => {

module.exports = require("tslib");

/***/ }),

/***/ "node:path":
/***/ ((module) => {

module.exports = require("node:path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

/**
 * This is not a production server yet!
 * This is only a minimal backend to get started.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__("tslib");
const common_1 = __webpack_require__("@nestjs/common");
const core_1 = __webpack_require__("@nestjs/core");
const platform_fastify_1 = __webpack_require__("@nestjs/platform-fastify");
const app_module_1 = __webpack_require__("../apps/api/src/app/app.module.ts");
function bootstrap() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const adapter = new platform_fastify_1.FastifyAdapter({ logger: {
                level: 'debug',
            } });
        adapter.enableCors({
            origin: true,
        });
        const app = yield core_1.NestFactory.create(app_module_1.AppModule, adapter);
        const globalPrefix = 'graphql';
        const port = process.env.PORT || 80;
        yield app.listen(port, '0.0.0.0');
        common_1.Logger.log(`ðŸš€ Application is running on: http://localhost:${port}/${globalPrefix}`);
    });
}
bootstrap();

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=main.js.map